<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../../.resources/report.gif" type="image/gif"/><title>Tools.java</title><link rel="stylesheet" href="../../../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../../.sessions.html" class="el_session">Sessions</a></span><a href="../../../index.html" class="el_report">freemind (Failed Tests first) (11 May, 2016 1:00:36 PM)</a> &gt; <a href="../../index.html" class="el_group">freemind</a> &gt; <a href="../index.html" class="el_bundle">freemind 1.0.0</a> &gt; <a href="index.source.html" class="el_package">freemind.main</a> &gt; <span class="el_source">Tools.java</span></div><h1>Tools.java</h1><pre class="source lang-java linenums">/*
 * FreeMind - a program for creating and viewing mindmaps
 * Copyright (C) 2000-2006  Joerg Mueller, Daniel Polansky, Christian Foltin and others.
 * See COPYING for details
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
 * details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
 * Place - Suite 330, Boston, MA 02111-1307, USA.
 */

package freemind.main;

//maybe move this class to another package like tools or something...

import java.awt.Color;
import java.awt.Component;
import java.awt.Container;
import java.awt.Dimension;
import java.awt.EventQueue;
import java.awt.Font;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Insets;
import java.awt.KeyboardFocusManager;
import java.awt.Point;
import java.awt.RenderingHints;
import java.awt.Toolkit;
import java.awt.datatransfer.Clipboard;
import java.awt.datatransfer.DataFlavor;
import java.awt.datatransfer.Transferable;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.KeyEvent;
import java.awt.print.Paper;
import java.io.BufferedReader;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.PrintStream;
import java.io.Reader;
import java.io.StringReader;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.net.InetAddress;
import java.net.MalformedURLException;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.URL;
import java.net.URLDecoder;
import java.net.UnknownHostException;
import java.security.spec.AlgorithmParameterSpec;
import java.security.spec.KeySpec;
import java.util.Arrays;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Properties;
import java.util.Random;
import java.util.Set;
import java.util.StringTokenizer;
import java.util.Vector;
import java.util.zip.DataFormatException;
import java.util.zip.Deflater;
import java.util.zip.Inflater;

<span class="nc" id="L86">import javax.crypto.Cipher;</span>
import javax.crypto.IllegalBlockSizeException;
import javax.crypto.SecretKey;
import javax.crypto.SecretKeyFactory;
import javax.crypto.spec.PBEKeySpec;
import javax.crypto.spec.PBEParameterSpec;
import javax.swing.AbstractAction;
import javax.swing.AbstractButton;
import javax.swing.Action;
import javax.swing.InputMap;
import javax.swing.JComponent;
import javax.swing.JDialog;
import javax.swing.KeyStroke;
import javax.swing.SwingUtilities;
import javax.swing.Timer;
import javax.swing.UIManager;
import javax.xml.transform.Result;
import javax.xml.transform.Source;
import javax.xml.transform.Transformer;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.stream.StreamResult;
import javax.xml.transform.stream.StreamSource;

import freemind.common.XmlBindingTools;
import freemind.controller.actions.generated.instance.CompoundAction;
import freemind.controller.actions.generated.instance.XmlAction;
import freemind.modes.MindMapNode;
import freemind.modes.mindmapmode.MindMapController;
import freemind.view.mindmapview.NodeView;

/**
 * @author foltin
 * 
 */
public class Tools {
	/**
	 * 
	 */
	public static final String FREEMIND_LIB_FREEMIND_JAR = &quot;lib/freemind.jar&quot;;

	private static java.util.logging.Logger logger = null;
	static {
		logger = freemind.main.Resources.getInstance().getLogger(&quot;Tools&quot;);
	}

	public static final String CONTENTS_JAVA_FREEMIND_JAR = &quot;Contents/Java/freemind.jar&quot;;

	public static final String FREE_MIND_APP_CONTENTS_RESOURCES_JAVA = &quot;Contents/Resources/Java/&quot;;

	// public static final Set executableExtensions = new HashSet ({ &quot;exe&quot;,
	// &quot;com&quot;, &quot;vbs&quot; });

	// The Java programming language provides a shortcut syntax for creating and
	// initializing an array. Here's an example of this syntax:
	// boolean[] answers = { true, false, true, true, false };

	public static final Set executableExtensions = new HashSet(
			Arrays.asList(new String[] { &quot;exe&quot;, &quot;com&quot;, &quot;vbs&quot;, &quot;bat&quot;, &quot;lnk&quot; }));

	private static Set availableFontFamilyNames = null; // Keep set of platform

	private static String sEnvFonts[] = null;

	// bug fix from Dimitri.
	public static Random ran = new Random();

	// fonts

<span class="nc" id="L154">	public static boolean executableByExtension(String file) {</span>
		return executableExtensions.contains(getExtension(file));
	}

<span class="nc" id="L158">	public static String colorToXml(Color col) {</span>
		// if (col == null) throw new IllegalArgumentException(&quot;Color was
		// null&quot;);
		if (col == null)
			return null;
		String red = Integer.toHexString(col.getRed());
		if (col.getRed() &lt; 16)
			red = &quot;0&quot; + red;
		String green = Integer.toHexString(col.getGreen());
		if (col.getGreen() &lt; 16)
			green = &quot;0&quot; + green;
		String blue = Integer.toHexString(col.getBlue());
		if (col.getBlue() &lt; 16)
			blue = &quot;0&quot; + blue;
		return &quot;#&quot; + red + green + blue;
	}

<span class="nc" id="L175">	public static Color xmlToColor(String string) {</span>
		if (string == null)
			return null;
		string = string.trim();
		if (string.length() == 7) {

			int red = Integer.parseInt(string.substring(1, 3), 16);
			int green = Integer.parseInt(string.substring(3, 5), 16);
			int blue = Integer.parseInt(string.substring(5, 7), 16);
			return new Color(red, green, blue);
		} else {
			throw new IllegalArgumentException(&quot;No xml color given by '&quot;
					+ string + &quot;'.&quot;);
		}
	}

<span class="nc" id="L191">	public static String PointToXml(Point col) {</span>
		if (col == null)
			return null; // throw new IllegalArgumentException(&quot;Point was
		// null&quot;);
		Vector l = new Vector();
		l.add(Integer.toString(col.x));
		l.add(Integer.toString(col.y));
		return listToString((List) l);
	}

<span class="nc" id="L201">	public static Point xmlToPoint(String string) {</span>
		if (string == null)
			return null;
		// fc, 3.11.2004: bug fix for alpha release of FM
		if (string.startsWith(&quot;java.awt.Point&quot;)) {
			string = string.replaceAll(
					&quot;java\\.awt\\.Point\\[x=(-*[0-9]*),y=(-*[0-9]*)\\]&quot;,
					&quot;$1;$2&quot;);
		}
		List l = stringToList(string);
		ListIterator it = l.listIterator(0);
		if (l.size() != 2)
			throw new IllegalArgumentException(
					&quot;A point must consist of two numbers (and not: '&quot; + string
							+ &quot;').&quot;);
		int x = Integer.parseInt((String) it.next());
		int y = Integer.parseInt((String) it.next());
		return new Point(x, y);
	}

<span class="nc" id="L221">	public static String BooleanToXml(boolean col) {</span>
		return (col) ? &quot;true&quot; : &quot;false&quot;;
	}

<span class="nc" id="L225">	public static boolean xmlToBoolean(String string) {</span>
		if (string == null)
			return false;
		if (string.equals(&quot;true&quot;))
			return true;
		return false;
	}

	/**
	 * Converts a String in the format &quot;value;value;value&quot; to a List with the
	 * values (as strings)
	 */
<span class="nc" id="L237">	public static List stringToList(String string) {</span>
		StringTokenizer tok = new StringTokenizer(string, &quot;;&quot;);
		List list = new LinkedList();
		while (tok.hasMoreTokens()) {
			list.add(tok.nextToken());
		}
		return list;
	}

<span class="nc" id="L246">	public static String listToString(List list) {</span>
		ListIterator it = list.listIterator(0);
		String str = new String();
		while (it.hasNext()) {
			str += it.next().toString() + &quot;;&quot;;
		}
		return str;
	}

	/**
	 * Replaces a ~ in a filename with the users home directory
	 */
<span class="nc" id="L258">	public static String expandFileName(String file) {</span>
		// replace ~ with the users home dir
		if (file.startsWith(&quot;~&quot;)) {
			file = System.getProperty(&quot;user.home&quot;) + file.substring(1);
		}
		return file;
	}

<span class="nc" id="L266">	public static Set getAvailableFontFamilyNames() {</span>
		if (availableFontFamilyNames == null) {
			String[] envFonts = getAvailableFonts();
			availableFontFamilyNames = new HashSet();
			for (int i = 0; i &lt; envFonts.length; i++) {
				availableFontFamilyNames.add(envFonts[i]);
			}
			// Add this one explicitly, Java defaults to it if the font is not
			availableFontFamilyNames.add(&quot;dialog&quot;);
		}
		return availableFontFamilyNames;
	}

	/**
     */
<span class="nc" id="L281">	private static String[] getAvailableFonts() {</span>
		if (sEnvFonts == null) {
			GraphicsEnvironment gEnv = GraphicsEnvironment
					.getLocalGraphicsEnvironment();
			sEnvFonts = gEnv.getAvailableFontFamilyNames();
		}
		return sEnvFonts;
	}

<span class="nc" id="L290">	public static Vector getAvailableFontFamilyNamesAsVector() {</span>
		String[] envFonts = getAvailableFonts();
		Vector availableFontFamilyNames = new Vector();
		for (int i = 0; i &lt; envFonts.length; i++) {
			availableFontFamilyNames.add(envFonts[i]);
		}
		return availableFontFamilyNames;
	}

<span class="fc" id="L299">	public static boolean isAvailableFontFamily(String fontFamilyName) {</span>
		return getAvailableFontFamilyNames().contains(fontFamilyName);
	}

	/**
	 * Returns the lowercase of the extension of a file. Example:
	 * getExtension(&quot;fork.pork.MM&quot;) ==
	 * freemind.main.FreeMindCommon.FREEMIND_FILE_EXTENSION_WITHOUT_DOT
	 */
<span class="nc" id="L308">	public static String getExtension(File f) {</span>
		return getExtension(f.toString());
	}

	/**
	 * Returns the lowercase of the extension of a file name. Example:
	 * getExtension(&quot;fork.pork.MM&quot;) ==
	 * freemind.main.FreeMindCommon.FREEMIND_FILE_EXTENSION_WITHOUT_DOT
	 */
<span class="nc" id="L317">	public static String getExtension(String s) {</span>
		int i = s.lastIndexOf('.');
		return (i &gt; 0 &amp;&amp; i &lt; s.length() - 1) ? s.substring(i + 1).toLowerCase()
				.trim() : &quot;&quot;;
	}

<span class="nc" id="L323">	public static String removeExtension(String s) {</span>
		int i = s.lastIndexOf('.');
		return (i &gt; 0 &amp;&amp; i &lt; s.length() - 1) ? s.substring(0, i) : &quot;&quot;;
	}

<span class="nc" id="L328">	public static boolean isAbsolutePath(String path) {</span>
		// On Windows, we cannot just ask if the file name starts with file
		// separator.
		// If path contains &quot;:&quot; at the second position, then it is not relative,
		// I guess.
		// However, if it starts with separator, then it is absolute too.

		// Possible problems: Not tested on Macintosh, but should work.
		// Koh, 1.4.2004: Resolved problem: I tested on Mac OS X 10.3.3 and
		// worked.

		String osNameStart = System.getProperty(&quot;os.name&quot;).substring(0, 3);
		String fileSeparator = System.getProperty(&quot;file.separator&quot;);
		if (osNameStart.equals(&quot;Win&quot;)) {
			return ((path.length() &gt; 1) &amp;&amp; path.substring(1, 2).equals(&quot;:&quot;))
					|| path.startsWith(fileSeparator);
		} else if (osNameStart.equals(&quot;Mac&quot;)) {
			// Koh:Panther (or Java 1.4.2) may change file path rule
			return path.startsWith(fileSeparator);
		} else {
			return path.startsWith(fileSeparator);
		}
	}

	/**
	 * This is a correction of a method getFile of a class URL. Namely, on
	 * Windows it returned file paths like /C: etc., which are not valid on
	 * Windows. This correction is heuristic to a great extend. One of the
	 * reasons is that file:// is basically no protocol at all, but rather
	 * something every browser and every system uses slightly differently.
	 */
<span class="nc" id="L359">	public static String urlGetFile(URL url) {</span>
		if (isWindows() &amp;&amp; isFile(url)) {
			String fileName = url.toString().replaceFirst(&quot;^file:&quot;, &quot;&quot;)
					.replace('/', '\\');
			return (fileName.indexOf(':') &gt;= 0) ? fileName.replaceFirst(
					&quot;^\\\\*&quot;, &quot;&quot;) : fileName;
		} // Network path
		else {
			return url.getFile();
		}
	}

<span class="fc" id="L371">	public static boolean isWindows() {</span>
		return System.getProperty(&quot;os.name&quot;).substring(0, 3).equals(&quot;Win&quot;);
	}

<span class="nc" id="L375">	public static boolean isFile(URL url) {</span>
		return url.getProtocol().equals(&quot;file&quot;);
	}

	/**
	 * @return &quot;/&quot; for absolute file names under Unix, &quot;c:\\&quot; or similar under
	 *         windows, null otherwise
	 */
<span class="nc" id="L383">	public static String getPrefix(String pFileName) {</span>
		if (isWindows()) {
			if (pFileName.matches(&quot;^[a-zA-Z]:\\\\.*&quot;)) {
				return pFileName.substring(0, 3);
			}
		} else {
			if (pFileName.startsWith(File.separator)) {
				return File.separator;
			}
		}
		return null;
	}

	/**
	 * This method converts an absolute url to an url relative to a given
	 * base-url. Something like this should be included in the librarys, but I
	 * couldn't find it. You can create a new absolute url with
	 * &quot;new URL(URL context, URL relative)&quot;.
	 */
<span class="nc" id="L402">	public static String toRelativeURL(URL base, URL target) {</span>
		// Precondition: If URL is a path to folder, then it must end with '/'
		// character.
		if (base == null || !base.getProtocol().equals(target.getProtocol())
				|| !base.getHost().equals(target.getHost())) {
			return target.toString();
		}
		String baseString = base.getFile();
		String targetString = target.getFile();
		String result = &quot;&quot;;
		// remove filename from URL
		targetString = targetString.substring(0,
				targetString.lastIndexOf(&quot;/&quot;) + 1);
		// remove filename from URL
		baseString = baseString.substring(0, baseString.lastIndexOf(&quot;/&quot;) + 1);

		// Algorithm
		// look for same start:
		int index = targetString.length() - 1;
		while (!baseString.startsWith(targetString.substring(0, index + 1))) {
			// remove last part:
			index = targetString.lastIndexOf(&quot;/&quot;, index - 1);
			if (index &lt; 0) {
				// no common part. This is strange, as both should start with /,
				// but...
				break;
			}
		}

		// now, baseString is targetString + &quot;/&quot; + rest. we determine
		// rest=baseStringRest now.
		String baseStringRest = baseString
				.substring(index, baseString.length());

		// Maybe this causes problems under windows
		StringTokenizer baseTokens = new StringTokenizer(baseStringRest, &quot;/&quot;);

		// Maybe this causes problems under windows
		StringTokenizer targetTokens = new StringTokenizer(
				targetString.substring(index + 1), &quot;/&quot;);

		String nextTargetToken = &quot;&quot;;

		while (baseTokens.hasMoreTokens()) {
			result = result.concat(&quot;../&quot;);
			baseTokens.nextToken();
		}
		while (targetTokens.hasMoreTokens()) {
			nextTargetToken = targetTokens.nextToken();
			result = result.concat(nextTargetToken + &quot;/&quot;);
		}

		String temp = target.getFile();
		result = result.concat(temp.substring(temp.lastIndexOf(&quot;/&quot;) + 1,
				temp.length()));
		return result;
	}

	/**
	 * If the preferences say, that links should be relative, a relative url is
	 * returned.
	 * 
	 * @param input
	 *            the file that is treated
	 * @param pMapFile
	 *            the file, that input is made relative to
	 * @return in case of trouble the absolute path.
	 */
<span class="fc" id="L470">	public static String fileToRelativeUrlString(File input, File pMapFile) {</span>
		URL link;
		String relative;
		try {
			link = Tools.fileToUrl(input);
			relative = link.toString();
			if (&quot;relative&quot;.equals(Resources.getInstance().getProperty(&quot;links&quot;))) {
				// Create relative URL
				relative = Tools.toRelativeURL(Tools.fileToUrl(pMapFile), link);
			}
			return relative;
		} catch (MalformedURLException ex) {
			freemind.main.Resources.getInstance().logException(ex);
		}
		return input.getAbsolutePath();
	}

	/**
	 * Tests a string to be equals with &quot;true&quot;.
	 * 
	 * @return true, iff the String is &quot;true&quot;.
	 */
<span class="nc" id="L492">	public static boolean isPreferenceTrue(String option) {</span>
		return Tools.safeEquals(option, &quot;true&quot;);
	}

	/**
	 * @param string1
	 *            input (or null)
	 * @param string2
	 *            input (or null)
	 * @return true, if equal (that means: same text or both null)
	 */
<span class="fc" id="L503">	public static boolean safeEquals(String string1, String string2) {</span>
		return (string1 != null &amp;&amp; string2 != null &amp;&amp; string1.equals(string2))
				|| (string1 == null &amp;&amp; string2 == null);
	}

<span class="nc" id="L508">	public static boolean safeEquals(Object obj1, Object obj2) {</span>
		return (obj1 != null &amp;&amp; obj2 != null &amp;&amp; obj1.equals(obj2))
				|| (obj1 == null &amp;&amp; obj2 == null);
	}

<span class="nc" id="L513">	public static boolean safeEqualsIgnoreCase(String string1, String string2) {</span>
		return (string1 != null &amp;&amp; string2 != null &amp;&amp; string1.toLowerCase()
				.equals(string2.toLowerCase()))
				|| (string1 == null &amp;&amp; string2 == null);
	}

<span class="nc" id="L519">	public static boolean safeEquals(Color color1, Color color2) {</span>
		return (color1 != null &amp;&amp; color2 != null &amp;&amp; color1.equals(color2))
				|| (color1 == null &amp;&amp; color2 == null);
	}

<span class="nc" id="L524">	public static String firstLetterCapitalized(String text) {</span>
		if (text == null || text.length() == 0) {
			return text;
		}
		return text.substring(0, 1).toUpperCase()
				+ text.substring(1, text.length());
	}

<span class="nc" id="L532">	public static void setHidden(File file, boolean hidden,</span>
			boolean synchronously) {
		// According to Web articles, UNIX systems do not have attribute hidden
		// in general, rather, they consider files starting with . as hidden.
		String osNameStart = System.getProperty(&quot;os.name&quot;).substring(0, 3);
		if (osNameStart.equals(&quot;Win&quot;)) {
			try {
				Runtime.getRuntime().exec(
						&quot;attrib &quot; + (hidden ? &quot;+&quot; : &quot;-&quot;) + &quot;H \&quot;&quot;
								+ file.getAbsolutePath() + &quot;\&quot;&quot;);
				// Synchronize the effect, because it is asynchronous in
				// general.
				if (!synchronously) {
					return;
				}
				int timeOut = 10;
				while (file.isHidden() != hidden &amp;&amp; timeOut &gt; 0) {
					Thread.sleep(10/* miliseconds */);
					timeOut--;
				}
			} catch (Exception e) {
				freemind.main.Resources.getInstance().logException(e);
			}
		}
	}

	/**
	 * Example: expandPlaceholders(&quot;Hello $1.&quot;,&quot;Dolly&quot;); =&gt; &quot;Hello Dolly.&quot;
	 */
<span class="nc" id="L561">	public static String expandPlaceholders(String message, String s1) {</span>
		String result = message;
		if (s1 != null) {
			s1 = s1.replaceAll(&quot;\\\\&quot;, &quot;\\\\\\\\&quot;); // Replace \ with \\
			result = result.replaceAll(&quot;\\$1&quot;, s1);
		}
		return result;
	}

<span class="nc" id="L570">	public static String expandPlaceholders(String message, String s1, String s2) {</span>
		String result = message;
		if (s1 != null) {
			result = result.replaceAll(&quot;\\$1&quot;, s1);
		}
		if (s2 != null) {
			result = result.replaceAll(&quot;\\$2&quot;, s2);
		}
		return result;
	}

<span class="nc" id="L581">	public static String expandPlaceholders(String message, String s1,</span>
			String s2, String s3) {
		String result = message;
		if (s1 != null) {
			result = result.replaceAll(&quot;\\$1&quot;, s1);
		}
		if (s2 != null) {
			result = result.replaceAll(&quot;\\$2&quot;, s2);
		}
		if (s3 != null) {
			result = result.replaceAll(&quot;\\$3&quot;, s3);
		}
		return result;
	}

	public static class IntHolder {
		private int value;

		public IntHolder() {
		}

		public IntHolder(int value) {
			this.value = value;
		}

<span class="nc" id="L606">		public void setValue(int value) {</span>
			this.value = value;
		}

<span class="nc" id="L610">		public int getValue() {</span>
			return value;
		}

<span class="nc" id="L614">		public String toString() {</span>
			return new String(&quot;IntHolder(&quot;) + value + &quot;)&quot;;
		}
	}

	public static class BooleanHolder {
		private boolean value;

		public BooleanHolder() {
		}

		public BooleanHolder(boolean initialValue) {
			value = initialValue;
		}

<span class="nc" id="L629">		public void setValue(boolean value) {</span>
			this.value = value;
		}

<span class="nc" id="L633">		public boolean getValue() {</span>
			return value;
		}
	}

	public static class ObjectHolder {
		Object object;

		public ObjectHolder() {
		}

<span class="nc" id="L644">		public void setObject(Object object) {</span>
			this.object = object;
		}

<span class="nc" id="L648">		public Object getObject() {</span>
			return object;
		}
	}

	public static class Pair {
		Object first;

		Object second;

		public Pair(Object first, Object second) {
			this.first = first;
			this.second = second;
		}

<span class="nc" id="L663">		public Object getFirst() {</span>
			return first;
		}

<span class="nc" id="L667">		public Object getSecond() {</span>
			return second;
		}
	}

	/** from: http://javaalmanac.com/egs/javax.crypto/PassKey.html */
	public static class DesEncrypter {
		private static final String SALT_PRESENT_INDICATOR = &quot; &quot;;
		private static final int SALT_LENGTH = 8;

		Cipher ecipher;

		Cipher dcipher;

		// 8-byte default Salt
		byte[] salt = { (byte) 0xA9, (byte) 0x9B, (byte) 0xC8, (byte) 0x32,
				(byte) 0x56, (byte) 0x35, (byte) 0xE3, (byte) 0x03 };

		// Iteration count
		int iterationCount = 19;

		private final char[] passPhrase;
		private String mAlgorithm;

		public DesEncrypter(StringBuffer pPassPhrase, String pAlgorithm) {
			passPhrase = new char[pPassPhrase.length()];
			pPassPhrase.getChars(0, passPhrase.length, passPhrase, 0);
			mAlgorithm = pAlgorithm;
		}

		/**
		 */
		private void init(byte[] mSalt) {
			if (mSalt != null) {
				this.salt = mSalt;
			}
<span class="nc" id="L703">			if (ecipher == null) {</span>
				try {
					// Create the key
					KeySpec keySpec = new PBEKeySpec(passPhrase, salt,
							iterationCount);
					SecretKey key = SecretKeyFactory.getInstance(mAlgorithm)
							.generateSecret(keySpec);
					ecipher = Cipher.getInstance(mAlgorithm);
					dcipher = Cipher.getInstance(mAlgorithm);

					// Prepare the parameter to the ciphers
					AlgorithmParameterSpec paramSpec = new PBEParameterSpec(
							salt, iterationCount);

					// Create the ciphers
					ecipher.init(Cipher.ENCRYPT_MODE, key, paramSpec);
					dcipher.init(Cipher.DECRYPT_MODE, key, paramSpec);
				} catch (java.security.InvalidAlgorithmParameterException e) {
				} catch (java.security.spec.InvalidKeySpecException e) {
				} catch (javax.crypto.NoSuchPaddingException e) {
				} catch (java.security.NoSuchAlgorithmException e) {
				} catch (java.security.InvalidKeyException e) {
				}
			}
		}

		public String encrypt(String str) {
			try {
				// Encode the string into bytes using utf-8
				byte[] utf8 = str.getBytes(&quot;UTF8&quot;);
				// determine salt by random:
				byte[] newSalt = new byte[SALT_LENGTH];
				for (int i = 0; i &lt; newSalt.length; i++) {
					newSalt[i] = (byte) (Math.random() * 256l - 128l);
				}

				init(newSalt);
				// Encrypt
<span class="nc" id="L741">				byte[] enc = ecipher.doFinal(utf8);</span>

				// Encode bytes to base64 to get a string
				return Tools.toBase64(newSalt) + SALT_PRESENT_INDICATOR
						+ Tools.toBase64(enc);
			} catch (javax.crypto.BadPaddingException e) {
			} catch (IllegalBlockSizeException e) {
			} catch (UnsupportedEncodingException e) {
			}
			return null;
		}

		public String decrypt(String str) {
			if (str == null) {
				return null;
			}
			try {
				byte[] salt = null;
				// test if salt exists:
				int indexOfSaltIndicator = str.indexOf(SALT_PRESENT_INDICATOR);
				if (indexOfSaltIndicator &gt;= 0) {
					String saltString = str.substring(0, indexOfSaltIndicator);
					str = str.substring(indexOfSaltIndicator + 1);
					salt = Tools.fromBase64(saltString);
				}
				// Decode base64 to get bytes
				str = str.replaceAll(&quot;\\s&quot;, &quot;&quot;);
				byte[] dec = Tools.fromBase64(str);
				init(salt);

				// Decrypt
<span class="nc" id="L772">				byte[] utf8 = dcipher.doFinal(dec);</span>

				// Decode using utf-8
				return new String(utf8, &quot;UTF8&quot;);
			} catch (javax.crypto.BadPaddingException e) {
			} catch (IllegalBlockSizeException e) {
			} catch (UnsupportedEncodingException e) {
			}
			return null;
		}
	}

	public static class SingleDesEncrypter extends DesEncrypter {

		public SingleDesEncrypter(StringBuffer pPassPhrase) {
			super(pPassPhrase, &quot;PBEWithMD5AndDES&quot;);
		}

	}

	public static class TripleDesEncrypter extends DesEncrypter {

		public TripleDesEncrypter(StringBuffer pPassPhrase) {
			super(pPassPhrase, &quot;PBEWithMD5AndTripleDES&quot;);
		}

	}

	/**
     */
<span class="nc" id="L802">	public static String toBase64(byte[] byteBuffer) {</span>
		return new String(Base64Coding.encode64(byteBuffer));
	}

	/** Method to be called from XSLT */
<span class="nc" id="L807">	public static String toBase64(String text) {</span>
		return toBase64(text.getBytes());
	}

	/**
	 * @throws IOException
	 */
<span class="fc" id="L814">	public static byte[] fromBase64(String base64String) {</span>
		return Base64Coding.decode64(base64String);
	}

<span class="nc" id="L818">	public static String compress(String message) {</span>
		byte[] input = uTF8StringToByteArray(message);
		// Create the compressor with highest level of compression
		Deflater compressor = new Deflater();
		compressor.setLevel(Deflater.BEST_COMPRESSION);

		// Give the compressor the data to compress
		compressor.setInput(input);
		compressor.finish();

		// Create an expandable byte array to hold the compressed data.
		// You cannot use an array that's the same size as the orginal because
		// there is no guarantee that the compressed data will be smaller than
		// the uncompressed data.
		ByteArrayOutputStream bos = new ByteArrayOutputStream(input.length);

		// Compress the data
		byte[] buf = new byte[1024];
		while (!compressor.finished()) {
			int count = compressor.deflate(buf);
			bos.write(buf, 0, count);
		}
		try {
			bos.close();
		} catch (IOException e) {
		}

		// Get the compressed data
		byte[] compressedData = bos.toByteArray();
		return toBase64(compressedData);
	}

<span class="nc" id="L850">	public static String decompress(String compressedMessage) {</span>
		byte[] compressedData = fromBase64(compressedMessage);
		// Create the decompressor and give it the data to compress
		Inflater decompressor = new Inflater();
		decompressor.setInput(compressedData);

		// Create an expandable byte array to hold the decompressed data
		ByteArrayOutputStream bos = new ByteArrayOutputStream(
				compressedData.length);

		// Decompress the data
		byte[] buf = new byte[1024];
		boolean errorOccured = false;
		while (!decompressor.finished() &amp;&amp; !errorOccured) {
			try {
				int count = decompressor.inflate(buf);
				bos.write(buf, 0, count);
			} catch (DataFormatException e) {
				errorOccured = true;
			}
		}
		try {
			bos.close();
		} catch (IOException e) {
		}

		// Get the decompressed data
		byte[] decompressedData = bos.toByteArray();
		return byteArrayToUTF8String(decompressedData);
	}

	/**
     */
<span class="nc" id="L883">	public static String byteArrayToUTF8String(byte[] compressedData) {</span>
		// Decode using utf-8
		try {
			return new String(compressedData, &quot;UTF8&quot;);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(&quot;UTF8 packing not allowed&quot;);
		}
	}

	/**
     */
<span class="nc" id="L894">	public static byte[] uTF8StringToByteArray(String uncompressedData) {</span>
		// Code using utf-8
		try {
			return uncompressedData.getBytes(&quot;UTF8&quot;);
		} catch (UnsupportedEncodingException e) {
			throw new RuntimeException(&quot;UTF8 packing not allowed&quot;);
		}
	}

	/**
	 * Extracts a long from xml. Only useful for dates.
	 */
<span class="nc" id="L906">	public static Date xmlToDate(String xmlString) {</span>
		try {
			return new Date(Long.valueOf(xmlString).longValue());
		} catch (Exception e) {
			return new Date(System.currentTimeMillis());
		}
	}

<span class="nc" id="L914">	public static String dateToString(Date date) {</span>
		return Long.toString(date.getTime());
	}

<span class="nc" id="L918">	public static boolean safeEquals(BooleanHolder holder, BooleanHolder holder2) {</span>
		return (holder == null &amp;&amp; holder2 == null)
				|| (holder != null &amp;&amp; holder2 != null &amp;&amp; holder.getValue() == holder2
						.getValue());
	}

<span class="nc" id="L924">	public static void setDialogLocationRelativeTo(JDialog dialog, Component c) {</span>
		if (c == null) {
			// perhaps, the component is not yet existing.
			return;
		}
		if (c instanceof NodeView) {
			final NodeView nodeView = (NodeView) c;
			nodeView.getMap().scrollNodeToVisible(nodeView);
			c = nodeView.getMainView();
		}
		final Point compLocation = c.getLocationOnScreen();
		final int cw = c.getWidth();
		final int ch = c.getHeight();

		final Container parent = dialog.getParent();
		final Point parentLocation = parent.getLocationOnScreen();
		final int pw = parent.getWidth();
		final int ph = parent.getHeight();

		final int dw = dialog.getWidth();
		final int dh = dialog.getHeight();

		final Toolkit defaultToolkit = Toolkit.getDefaultToolkit();
		final Dimension screenSize = defaultToolkit.getScreenSize();
		final Insets screenInsets = defaultToolkit.getScreenInsets(dialog
				.getGraphicsConfiguration());

		final int minX = Math.max(parentLocation.x, screenInsets.left);
		final int minY = Math.max(parentLocation.y, screenInsets.top);

		final int maxX = Math.min(parentLocation.x + pw, screenSize.width
				- screenInsets.right);
		final int maxY = Math.min(parentLocation.y + ph, screenSize.height
				- screenInsets.bottom);

		int dx, dy;

		if (compLocation.x + cw &lt; minX) {
			dx = minX;
		} else if (compLocation.x &gt; maxX) {
			dx = maxX - dw;
		} else // component X on screen
		{
			final int leftSpace = compLocation.x - minX;
			final int rightSpace = maxX - (compLocation.x + cw);
			if (leftSpace &gt; rightSpace) {
				if (leftSpace &gt; dw) {
					dx = compLocation.x - dw;
				} else {
					dx = minX;
				}
			} else {
				if (rightSpace &gt; dw) {
					dx = compLocation.x + cw;
				} else {
					dx = maxX - dw;
				}
			}
		}

		if (compLocation.y + ch &lt; minY) {
			dy = minY;
		} else if (compLocation.y &gt; maxY) {
			dy = maxY - dh;
		} else // component Y on screen
		{
			final int topSpace = compLocation.y - minY;
			final int bottomSpace = maxY - (compLocation.y + ch);
			if (topSpace &gt; bottomSpace) {
				if (topSpace &gt; dh) {
					dy = compLocation.y - dh;
				} else {
					dy = minY;
				}
			} else {
				if (bottomSpace &gt; dh) {
					dy = compLocation.y + ch;
				} else {
					dy = maxY - dh;
				}
			}
		}

		dialog.setLocation(dx, dy);
	}

	/**
	 * Creates a reader that pipes the input file through a XSLT-Script that
	 * updates the version to the current.
	 * 
	 * @throws IOException
	 */
<span class="fc" id="L1016">	public static Reader getUpdateReader(Reader pReader, String xsltScript,</span>
			FreeMindMain frame) throws IOException {
		StringWriter writer = null;
		InputStream inputStream = null;
		final java.util.logging.Logger logger = frame.getLogger(Tools.class
				.getName());
		logger.info(&quot;Updating the reader &quot; + pReader
				+ &quot; to the current version.&quot;);
		boolean successful = false;
		String errorMessage = null;
		try {
			// try to convert map with xslt:
			URL updaterUrl = null;
			updaterUrl = frame.getResource(xsltScript);
			if (updaterUrl == null) {
				throw new IllegalArgumentException(xsltScript + &quot; not found.&quot;);
			}
			inputStream = updaterUrl.openStream();
			final Source xsltSource = new StreamSource(inputStream);
			// get output:
			writer = new StringWriter();
			final Result result = new StreamResult(writer);

			String fileContents = getFile(pReader);
			if (fileContents.length() &gt; 10) {
				logger.info(&quot;File start before UTF8 replacement: '&quot;
						+ fileContents.substring(0, 9) + &quot;'&quot;);
			}
			fileContents = replaceUtf8AndIllegalXmlChars(fileContents);
			if (fileContents.length() &gt; 10) {
				logger.info(&quot;File start after UTF8 replacement: '&quot;
						+ fileContents.substring(0, 9) + &quot;'&quot;);
			}
			final StreamSource sr = new StreamSource(new StringReader(
					fileContents));
			// Dimitry: to avoid a memory leak and properly release resources
			// after the XSLT transformation
			// everything should run in own thread. Only after the thread dies
			// the resources are released.
			class TransformerRunnable implements Runnable {
				private boolean successful = false;
				private String errorMessage;

				public void run() {
					// create an instance of TransformerFactory
					TransformerFactory transFact = TransformerFactory
							.newInstance();
					logger.info(&quot;TransformerFactory class: &quot;
							+ transFact.getClass());
					Transformer trans;
					try {
						trans = transFact.newTransformer(xsltSource);
						trans.transform(sr, result);
						successful = true;
					} catch (Exception ex) {
						freemind.main.Resources.getInstance().logException(ex);
						errorMessage = ex.toString();
					}
				}

				public boolean isSuccessful() {
					return successful;
				}

				public String getErrorMessage() {
					return errorMessage;
				}
			}
			final TransformerRunnable transformer = new TransformerRunnable();
			Thread transformerThread = new Thread(transformer, &quot;XSLT&quot;);
			transformerThread.start();
			transformerThread.join();
			logger.info(&quot;Updating the reader &quot; + pReader
					+ &quot; to the current version. Done.&quot;); // +
															// writer.getBuffer().toString());
			successful = transformer.isSuccessful();
			errorMessage = transformer.getErrorMessage();
		} catch (Exception ex) {
			Resources.getInstance().logException(ex, xsltScript);
			errorMessage = ex.getLocalizedMessage();
		} finally {
			if (inputStream != null) {
				inputStream.close();
			}
			if (writer != null) {
				writer.close();
			}
		}
		if (successful) {
			String content = writer.getBuffer().toString();
			// logger.info(&quot;Content before transformation: &quot; + content);
			String replacedContent = Tools
					.replaceUtf8AndIllegalXmlChars(content);
			// logger.info(&quot;Content after transformation: &quot; + replacedContent);
			return new StringReader(replacedContent);
		} else {
			return new StringReader(&quot;&lt;map&gt;&lt;node TEXT='&quot;
					+ HtmlTools.toXMLEscapedText(errorMessage) + &quot;'/&gt;&lt;/map&gt;&quot;);
		}
	}

<span class="fc" id="L1117">	public static String replaceUtf8AndIllegalXmlChars(String fileContents) {</span>
		return HtmlTools.removeInvalidXmlCharacters(fileContents);
	}

	/**
	 * Creates a default reader that just reads the given file.
	 * 
	 * @throws FileNotFoundException
	 */
<span class="nc" id="L1126">	public static Reader getActualReader(Reader pReader)</span>
			throws FileNotFoundException {
		return new BufferedReader(pReader);
	}

	/**
	 * In case of trouble, the method returns null.
	 * 
	 * @param pInputFile
	 *            the file to read.
	 * @return the complete content of the file. or null if an exception has
	 *         occured.
	 */
<span class="nc" id="L1139">	public static String getFile(File pInputFile) {</span>
		try {
			return getFile(getReaderFromFile(pInputFile));
		} catch (FileNotFoundException e) {
			freemind.main.Resources.getInstance().logException(e);
			return null;
		}
	}

<span class="nc" id="L1148">	public static Reader getReaderFromFile(File pInputFile)</span>
			throws FileNotFoundException {
		return new FileReader(pInputFile);
	}

<span class="nc" id="L1153">	public static String getFile(Reader pReader) {</span>
		StringBuffer lines = new StringBuffer();
		BufferedReader bufferedReader = null;
		try {
			bufferedReader = new BufferedReader(pReader);
			final String endLine = System.getProperty(&quot;line.separator&quot;);
			String line;
			while ((line = bufferedReader.readLine()) != null) {
				lines.append(line).append(endLine);
			}
			bufferedReader.close();
		} catch (Exception e) {
			freemind.main.Resources.getInstance().logException(e);
			if (bufferedReader != null) {
				try {
					bufferedReader.close();
				} catch (Exception ex) {
					freemind.main.Resources.getInstance().logException(ex);
				}
			}
			return null;
		}
		return lines.toString();
	}

<span class="nc" id="L1178">	public static void logTransferable(Transferable t) {</span>
		System.err.println();
		System.err.println(&quot;BEGIN OF Transferable:\t&quot; + t);
		DataFlavor[] dataFlavors = t.getTransferDataFlavors();
		for (int i = 0; i &lt; dataFlavors.length; i++) {
			System.out.println(&quot;  Flavor:\t&quot; + dataFlavors[i]);
			System.out.println(&quot;    Supported:\t&quot;
					+ t.isDataFlavorSupported(dataFlavors[i]));
			try {
				System.out.println(&quot;    Content:\t&quot;
						+ t.getTransferData(dataFlavors[i]));
			} catch (Exception e) {
			}
		}
		System.err.println(&quot;END OF Transferable&quot;);
		System.err.println();
	}

<span class="nc" id="L1196">	public static void addEscapeActionToDialog(final JDialog dialog) {</span>
		class EscapeAction extends AbstractAction {
			private static final long serialVersionUID = 238333614987438806L;

			public void actionPerformed(ActionEvent e) {
				dialog.dispose();
			};
		}
		addEscapeActionToDialog(dialog, new EscapeAction());
	}

<span class="nc" id="L1207">	public static void addEscapeActionToDialog(JDialog dialog, Action action) {</span>
		addKeyActionToDialog(dialog, action, &quot;ESCAPE&quot;, &quot;end_dialog&quot;);
	}

<span class="nc" id="L1211">	public static void addKeyActionToDialog(JDialog dialog, Action action,</span>
			String keyStroke, String actionId) {
		action.putValue(Action.NAME, actionId);
		// Register keystroke
		dialog.getRootPane()
				.getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)
				.put(KeyStroke.getKeyStroke(keyStroke),
						action.getValue(Action.NAME));

		// Register action
		dialog.getRootPane().getActionMap()
				.put(action.getValue(Action.NAME), action);
	}

	/**
	 * Removes the &quot;TranslateMe&quot; sign from the end of not translated texts.
	 */
<span class="nc" id="L1228">	public static String removeTranslateComment(String inputString) {</span>
		if (inputString != null
				&amp;&amp; inputString.endsWith(FreeMindCommon.POSTFIX_TRANSLATE_ME)) {
			// remove POSTFIX_TRANSLATE_ME:
			inputString = inputString.substring(0, inputString.length()
					- FreeMindCommon.POSTFIX_TRANSLATE_ME.length());
		}
		return inputString;
	}

	/**
	 * Returns the same URL as input with the addition, that the reference part
	 * &quot;#...&quot; is filtered out.
	 * 
	 * @throws MalformedURLException
	 */
<span class="nc" id="L1244">	public static URL getURLWithoutReference(URL input)</span>
			throws MalformedURLException {
		return new URL(input.toString().replaceFirst(&quot;#.*&quot;, &quot;&quot;));
	}

<span class="fc" id="L1249">	public static void copyStream(InputStream in, OutputStream out,</span>
			boolean pCloseOutput) throws IOException {
		byte[] buf = new byte[1024];
		int len;
		while ((len = in.read(buf)) &gt; 0) {
			out.write(buf, 0, len);
		}
		in.close();
		if (pCloseOutput) {
			out.close();
		}
	}

<span class="nc" id="L1262">	public static Point convertPointToAncestor(Component c, Point p,</span>
			Component destination) {
		int x, y;
		while (c != destination) {
			x = c.getX();
			y = c.getY();

			p.x += x;
			p.y += y;

			c = c.getParent();
		}
		return p;

	}

<span class="nc" id="L1278">	public static void convertPointFromAncestor(Component source, Point p,</span>
			Component c) {
		int x, y;
		while (c != source) {
			x = c.getX();
			y = c.getY();

			p.x -= x;
			p.y -= y;

			c = c.getParent();
		}
		;

	}

<span class="nc" id="L1294">	public static void convertPointToAncestor(Component source, Point point,</span>
			Class ancestorClass) {
		Component destination = SwingUtilities.getAncestorOfClass(
				ancestorClass, source);
		convertPointToAncestor(source, point, destination);
	}

	interface NameMnemonicHolder {

		/**
		 */
		String getText();

		/**
		 */
		void setText(String replaceAll);

		/**
		 */
		void setMnemonic(char charAfterMnemoSign);

		/**
		 */
		void setDisplayedMnemonicIndex(int mnemoSignIndex);

	}

	private static class ButtonHolder implements NameMnemonicHolder {
		private AbstractButton btn;

		public ButtonHolder(AbstractButton btn) {
			super();
			this.btn = btn;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#getText()
		 */
<span class="nc" id="L1334">		public String getText() {</span>
			return btn.getText();
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * freemind.main.Tools.IAbstractButton#setDisplayedMnemonicIndex(int)
		 */
<span class="nc" id="L1344">		public void setDisplayedMnemonicIndex(int mnemoSignIndex) {</span>
			btn.setDisplayedMnemonicIndex(mnemoSignIndex);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#setMnemonic(char)
		 */
<span class="nc" id="L1353">		public void setMnemonic(char charAfterMnemoSign) {</span>
			btn.setMnemonic(charAfterMnemoSign);
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#setText(java.lang.String)
		 */
<span class="nc" id="L1362">		public void setText(String text) {</span>
			btn.setText(text);
		}

	}

	private static class ActionHolder implements NameMnemonicHolder {
		private Action action;

		public ActionHolder(Action action) {
			super();
			this.action = action;
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#getText()
		 */
<span class="nc" id="L1381">		public String getText() {</span>
			return action.getValue(Action.NAME).toString();
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see
		 * freemind.main.Tools.IAbstractButton#setDisplayedMnemonicIndex(int)
		 */
<span class="nc" id="L1391">		public void setDisplayedMnemonicIndex(int mnemoSignIndex) {</span>
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#setMnemonic(char)
		 */
<span class="nc" id="L1399">		public void setMnemonic(char charAfterMnemoSign) {</span>
			int vk = (int) charAfterMnemoSign;
			if (vk &gt;= 'a' &amp;&amp; vk &lt;= 'z')
				vk -= ('a' - 'A');
			action.putValue(Action.MNEMONIC_KEY, new Integer(vk));
		}

		/*
		 * (non-Javadoc)
		 * 
		 * @see freemind.main.Tools.IAbstractButton#setText(java.lang.String)
		 */
<span class="nc" id="L1411">		public void setText(String text) {</span>
			action.putValue(Action.NAME, text);
		}

	}

	public static class MindMapNodePair {
		MindMapNode first;

		MindMapNode second;

		public MindMapNodePair(MindMapNode first, MindMapNode second) {
			this.first = first;
			this.second = second;
		}

<span class="nc" id="L1427">		public MindMapNode getCorresponding() {</span>
			return first;
		}

<span class="nc" id="L1431">		public MindMapNode getCloneNode() {</span>
			return second;
		}
	}

	/**
	 * Ampersand indicates that the character after it is a mnemo, unless the
	 * character is a space. In &quot;Find &amp; Replace&quot;, ampersand does not label
	 * mnemo, while in &quot;&amp;About&quot;, mnemo is &quot;Alt + A&quot;.
	 */
<span class="nc" id="L1441">	public static void setLabelAndMnemonic(AbstractButton btn, String inLabel) {</span>
		setLabelAndMnemonic(new ButtonHolder(btn), inLabel);
	}

	/**
	 * Ampersand indicates that the character after it is a mnemo, unless the
	 * character is a space. In &quot;Find &amp; Replace&quot;, ampersand does not label
	 * mnemo, while in &quot;&amp;About&quot;, mnemo is &quot;Alt + A&quot;.
	 */
<span class="nc" id="L1450">	public static void setLabelAndMnemonic(Action action, String inLabel) {</span>
		setLabelAndMnemonic(new ActionHolder(action), inLabel);
	}

<span class="nc" id="L1454">	private static void setLabelAndMnemonic(NameMnemonicHolder item,</span>
			String inLabel) {
		String rawLabel = inLabel;
		if (rawLabel == null)
			rawLabel = item.getText();
		if (rawLabel == null)
			return;
		item.setText(removeMnemonic(rawLabel));
		int mnemoSignIndex = rawLabel.indexOf(&quot;&amp;&quot;);
		if (mnemoSignIndex &gt;= 0 &amp;&amp; mnemoSignIndex + 1 &lt; rawLabel.length()) {
			char charAfterMnemoSign = rawLabel.charAt(mnemoSignIndex + 1);
			if (charAfterMnemoSign != ' ') {
				// no mnemonics under Mac OS:
				if (!isMacOsX()) {
					item.setMnemonic(charAfterMnemoSign);
					// sets the underline to exactly this character.
					item.setDisplayedMnemonicIndex(mnemoSignIndex);
				}
			}
		}
	}

<span class="nc" id="L1476">	public static boolean isMacOsX() {</span>
		boolean underMac = false;
		String osName = System.getProperty(&quot;os.name&quot;);
		if (osName.startsWith(&quot;Mac OS&quot;)) {
			underMac = true;
		}
		return underMac;
	}

<span class="nc" id="L1485">	public static boolean isLinux() {</span>
		boolean underLinux = false;
		String osName = System.getProperty(&quot;os.name&quot;);
		if (osName.startsWith(&quot;Linux&quot;)) {
			underLinux = true;
		}
		return underLinux;
	}

<span class="nc" id="L1494">	public static String removeMnemonic(String rawLabel) {</span>
		return rawLabel.replaceFirst(&quot;&amp;([^ ])&quot;, &quot;$1&quot;);
	}

<span class="nc" id="L1498">	public static KeyStroke getKeyStroke(final String keyStrokeDescription) {</span>
		if (keyStrokeDescription == null) {
			return null;
		}
		final KeyStroke keyStroke = KeyStroke
				.getKeyStroke(keyStrokeDescription);
		if (keyStroke != null)
			return keyStroke;
		return KeyStroke.getKeyStroke(&quot;typed &quot; + keyStrokeDescription);
	}

	public static final String JAVA_VERSION = System
			.getProperty(&quot;java.version&quot;);

<span class="fc" id="L1512">	public static URL fileToUrl(File pFile) throws MalformedURLException {</span>
		if (pFile == null)
			return null;
		return pFile.toURI().toURL();
	}

<span class="nc" id="L1518">	public static boolean isBelowJava6() {</span>
		return JAVA_VERSION.compareTo(&quot;1.6.0&quot;) &lt; 0;
	}

<span class="nc" id="L1522">	public static boolean isAboveJava4() {</span>
		return JAVA_VERSION.compareTo(&quot;1.4.0&quot;) &gt; 0;
	}

<span class="nc" id="L1526">	public static File urlToFile(URL pUrl) throws URISyntaxException {</span>
		// fix for java1.4 and java5 only.
		if (isBelowJava6()) {
			return new File(urlGetFile(pUrl));
		}
		return new File(new URI(pUrl.toString()));
	}

<span class="nc" id="L1534">	public static void restoreAntialiasing(Graphics2D g, Object renderingHint) {</span>
		if (RenderingHints.KEY_ANTIALIASING.isCompatibleValue(renderingHint)) {
			g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, renderingHint);
		}
	}

<span class="nc" id="L1540">	public static String getFileNameProposal(MindMapNode node) {</span>
		String rootText = node.getPlainTextContent();
		rootText = rootText.replaceAll(&quot;[&amp;:/\\\\\0%$#~\\?\\*]+&quot;, &quot;&quot;);
		return rootText;
	}

<span class="nc" id="L1546">	public static void waitForEventQueue() {</span>
		try {
			// wait until AWT thread starts
			// final Exception e = new IllegalArgumentException(&quot;HERE&quot;);
			if (!EventQueue.isDispatchThread()) {
				EventQueue.invokeAndWait(new Runnable() {
					public void run() {
						// logger.info(&quot;Waited for event queue.&quot;);
						// e.printStackTrace();
					};
				});
			} else {
				logger.warning(&quot;Can't wait for event queue, if I'm inside this queue!&quot;);
			}
		} catch (Exception e) {
			freemind.main.Resources.getInstance().logException(e);
		}
	}

	/**
	 * Logs the stacktrace via a dummy exception.
	 */
<span class="nc" id="L1568">	public static void printStackTrace() {</span>
		freemind.main.Resources.getInstance().logException(
				new IllegalArgumentException(&quot;HERE&quot;));
	}

	/**
	 * Logs the stacktrace into a string.
	 */
<span class="nc" id="L1576">	public static String getStackTrace() {</span>
		IllegalArgumentException ex = new IllegalArgumentException(&quot;HERE&quot;);
		ByteArrayOutputStream b = new ByteArrayOutputStream();
		ex.printStackTrace(new PrintStream(b));
		return b.toString();
	}

	/**
	 * Adapts the font size inside of a component to the zoom
	 * 
	 * @param c
	 *            component
	 * @param zoom
	 *            zoom factor
	 * @param normalFontSize
	 *            &quot;unzoomed&quot; normal font size.
	 * @return a copy of the input font (if the size was effectively changed)
	 *         with the correct scale.
	 */
<span class="nc" id="L1595">	public static Font updateFontSize(Font font, float zoom, int normalFontSize) {</span>
		if (font != null) {
			float oldFontSize = font.getSize2D();
			float newFontSize = normalFontSize * zoom;
			if (oldFontSize != newFontSize) {
				font = font.deriveFont(newFontSize);
			}
		}
		return font;
	}

<span class="nc" id="L1606">	public static String compareText(String pText1, String pText2) {</span>
		if (pText1 == null || pText2 == null) {
			return &quot;One of the Strings is null &quot; + pText1 + &quot;, &quot; + pText2;
		}
		StringBuffer b = new StringBuffer();
		if (pText1.length() &gt; pText2.length()) {
			b.append(&quot;First string is longer :&quot;
					+ pText1.substring(pText2.length()) + &quot;\n&quot;);
		}
		if (pText1.length() &lt; pText2.length()) {
			b.append(&quot;Second string is longer :&quot;
					+ pText2.substring(pText1.length()) + &quot;\n&quot;);
		}
		for (int i = 0; i &lt; Math.min(pText1.length(), pText2.length()); i++) {
			if (pText1.charAt(i) != pText2.charAt(i)) {
				b.append(&quot;Difference at &quot; + i + &quot;: &quot; + pText1.charAt(i) + &quot;!=&quot;
						+ pText2.charAt(i) + &quot;\n&quot;);
			}

		}
		return b.toString();
	}

<span class="nc" id="L1629">	public static String getHostName() {</span>
		String hostname = &quot;UNKNOWN&quot;;
		try {
			InetAddress addr = InetAddress.getLocalHost();
			hostname = addr.getHostName();
		} catch (UnknownHostException e) {
		}
		return hostname;
	}

<span class="nc" id="L1639">	public static String getUserName() {</span>
		// Get host name
		String hostname = getHostName();
		return System.getProperty(&quot;user.name&quot;) + &quot;@&quot; + hostname;
	}

<span class="nc" id="L1645">	public static String marshall(XmlAction action) {</span>
		return XmlBindingTools.getInstance().marshall(action);
	}

<span class="fc" id="L1649">	public static XmlAction unMarshall(String inputString) {</span>
		return XmlBindingTools.getInstance().unMarshall(inputString);
	}

<span class="nc" id="L1653">	public static String getFileNameFromRestorable(String restoreable) {</span>
		StringTokenizer token = new StringTokenizer(restoreable, &quot;:&quot;);
		String fileName;
		if (token.hasMoreTokens()) {
			token.nextToken();
			// fix for windows (??, fc, 25.11.2005).
			fileName = token.nextToken(&quot;&quot;).substring(1);
		} else {
			fileName = null;
		}
		return fileName;
	}

<span class="nc" id="L1666">	public static String getModeFromRestorable(String restoreable) {</span>
		StringTokenizer token = new StringTokenizer(restoreable, &quot;:&quot;);
		String mode;
		if (token.hasMoreTokens()) {
			mode = token.nextToken();
		} else {
			mode = null;
		}
		return mode;
	}

<span class="nc" id="L1677">	public static Vector getVectorWithSingleElement(Object obj) {</span>
		Vector nodes = new Vector();
		nodes.add(obj);
		return nodes;
	}

<span class="nc" id="L1683">	public static void swapVectorPositions(Vector pVector, int src, int dst) {</span>
		if (src &gt;= pVector.size() || dst &gt;= pVector.size() || src &lt; 0
				|| dst &lt; 0) {
			throw new IllegalArgumentException(&quot;One index is out of bounds &quot;
					+ src + &quot;, &quot; + dst + &quot;, size= &quot; + pVector.size());
		}
		pVector.set(dst, pVector.set(src, pVector.get(dst)));
	}

<span class="nc" id="L1692">	public static Object getField(Object[] pObjects, String pField)</span>
			throws IllegalArgumentException, SecurityException,
			IllegalAccessException, NoSuchFieldException {
		for (int i = 0; i &lt; pObjects.length; i++) {
			Object object = pObjects[i];
			for (int j = 0; j &lt; object.getClass().getFields().length; j++) {
				Field f = object.getClass().getFields()[j];
				if (Tools.safeEquals(pField, f.getName())) {
					return object.getClass().getField(pField).get(object);
				}
			}
		}
		return null;
	}

<span class="nc" id="L1707">	public static boolean isUnix() {</span>
		return (File.separatorChar == '/') || isMacOsX();
	}

	// {{{ setPermissions() method
	/**
	 * Sets numeric permissions of a file. On non-Unix platforms, does nothing.
	 * From jEdit
	 */
<span class="nc" id="L1716">	public static void setPermissions(String path, int permissions) {</span>

		if (permissions != 0) {
			if (isUnix()) {
				String[] cmdarray = { &quot;chmod&quot;,
						Integer.toString(permissions, 8), path };

				try {
					Process process = Runtime.getRuntime().exec(cmdarray);
					process.getInputStream().close();
					process.getOutputStream().close();
					process.getErrorStream().close();
					// Jun 9 2004 12:40 PM
					// waitFor() hangs on some Java
					// implementations.
					/*
					 * int exitCode = process.waitFor(); if(exitCode != 0)
					 * Log.log
					 * (Log.NOTICE,FileVFS.class,&quot;chmod exited with code &quot; +
					 * exitCode);
					 */
				}

				// Feb 4 2000 5:30 PM
				// Catch Throwable here rather than Exception.
				// Kaffe's implementation of Runtime.exec throws
				// java.lang.InternalError.
				catch (Throwable t) {
				}
			}
		}
	} // }}}

<span class="fc" id="L1749">	public static String arrayToUrls(String[] pArgs) {</span>
		StringBuffer b = new StringBuffer();
		for (int i = 0; i &lt; pArgs.length; i++) {
			String fileName = pArgs[i];
			try {
				b.append(fileToUrl(new File(fileName)));
				b.append('\n');
			} catch (MalformedURLException e) {
				freemind.main.Resources.getInstance().logException(e);
			}
		}
		return b.toString();
	}

<span class="nc" id="L1763">	public static Vector/* &lt;URL&gt; */urlStringToUrls(String pUrls) {</span>
		String[] urls = pUrls.split(&quot;\n&quot;);
		Vector ret = new Vector();
		for (int i = 0; i &lt; urls.length; i++) {
			String url = urls[i];
			try {
				ret.add(new URL(url));
			} catch (MalformedURLException e) {
				freemind.main.Resources.getInstance().logException(e);
			}
		}
		return ret;
	}

	/**
	 * @return
	 */
<span class="nc" id="L1780">	public static boolean isHeadless() {</span>
		return GraphicsEnvironment.getLocalGraphicsEnvironment().isHeadless();
	}

	/**
	 * @param pNode
	 * @param pMindMapController
	 * @return
	 */
<span class="nc" id="L1789">	public static String getNodeTextHierarchy(MindMapNode pNode,</span>
			MindMapController pMindMapController) {
		return pNode.getShortText(pMindMapController)
				+ ((pNode.isRoot()) ? &quot;&quot; : (&quot; &lt;- &quot; + getNodeTextHierarchy(
						pNode.getParentNode(), pMindMapController)));
	}

	/**
     */
<span class="nc" id="L1798">	public static Clipboard getClipboard() {</span>
		return Toolkit.getDefaultToolkit().getSystemClipboard();
	}

<span class="nc" id="L1802">	public static void addFocusPrintTimer() {</span>
		Timer timer = new Timer(1000, new ActionListener() {

			public void actionPerformed(ActionEvent pE) {
				logger.info(&quot;Component: &quot;
						+ KeyboardFocusManager.getCurrentKeyboardFocusManager()
								.getFocusOwner()
						+ &quot;, Window: &quot;
						+ KeyboardFocusManager.getCurrentKeyboardFocusManager()
								.getFocusedWindow());
			}
		});
		timer.start();

	}

	/**
	 * copied from HomePane.java 15 mai 2006
	 * 
	 * Sweet Home 3D, Copyright (c) 2006 Emmanuel PUYBARET / eTeks
	 * &lt;info@eteks.com&gt;
	 * 
	 * - This listener manages accelerator keys that may require the use of
	 * shift key depending on keyboard layout (like + - or ?)
	 */
<span class="nc" id="L1827">	public static void invokeActionsToKeyboardLayoutDependantCharacters(</span>
			KeyEvent pEvent, Action[] specialKeyActions, Object pObject) {
		// on purpose without shift.
		int modifiersMask = KeyEvent.ALT_MASK | KeyEvent.CTRL_MASK
				| KeyEvent.META_MASK;
		for (int i = 0; i &lt; specialKeyActions.length; i++) {
			Action specialKeyAction = specialKeyActions[i];
			KeyStroke actionKeyStroke = (KeyStroke) specialKeyAction
					.getValue(Action.ACCELERATOR_KEY);
			if (pEvent.getKeyChar() == actionKeyStroke.getKeyChar()
					&amp;&amp; (pEvent.getModifiers() &amp; modifiersMask) == (actionKeyStroke
							.getModifiers() &amp; modifiersMask)
					&amp;&amp; specialKeyAction.isEnabled()) {
				specialKeyAction.actionPerformed(new ActionEvent(pObject,
						ActionEvent.ACTION_PERFORMED, (String) specialKeyAction
								.getValue(Action.ACTION_COMMAND_KEY)));
				pEvent.consume();
			}
		}
	}

	/**
	 * @param pString
	 * @param pSearchString
	 * @return the amount of occurrences of pSearchString in pString.
	 */
<span class="fc" id="L1853">	public static int countOccurrences(String pString, String pSearchString) {</span>
		int amount = 0;
		while (true) {
			final int index = pString.indexOf(pSearchString);
			if (index &lt; 0) {
				break;
			}
			amount++;
			pString = pString.substring(index + pSearchString.length());
		}
		return amount;
	}

<span class="nc" id="L1866">	public static void correctJSplitPaneKeyMap() {</span>
		InputMap map = (InputMap) UIManager.get(&quot;SplitPane.ancestorInputMap&quot;);
		KeyStroke keyStrokeF6 = KeyStroke.getKeyStroke(KeyEvent.VK_F6, 0);
		KeyStroke keyStrokeF8 = KeyStroke.getKeyStroke(KeyEvent.VK_F8, 0);
		map.remove(keyStrokeF6);
		map.remove(keyStrokeF8);
	}

	/**
	 * @param pPageFormat
	 * @param pPageFormatProperty
	 */
<span class="nc" id="L1878">	public static void setPageFormatFromString(Paper pPaper,</span>
			String pPageFormatProperty) {
		try {
			// parse string:
			StringTokenizer tokenizer = new StringTokenizer(
					pPageFormatProperty, &quot;;&quot;);
			if (tokenizer.countTokens() != 6) {
				logger.warning(&quot;Page format property has not the correct format:&quot;
						+ pPageFormatProperty);
				return;
			}
			pPaper.setSize(nt(tokenizer), nt(tokenizer));
			pPaper.setImageableArea(nt(tokenizer), nt(tokenizer),
					nt(tokenizer), nt(tokenizer));
		} catch (Exception e) {
			freemind.main.Resources.getInstance().logException(e);
		}
	}

	/**
	 * @param pTokenizer
	 * @return
	 */
<span class="nc" id="L1901">	private static double nt(StringTokenizer pTokenizer) {</span>
		String nextToken = pTokenizer.nextToken();
		try {
			return Double.parseDouble(nextToken);
		} catch (Exception e) {
			freemind.main.Resources.getInstance().logException(e);
		}
		return 0;
	}

	/**
	 * @param pPageFormat
	 * @return
	 */
<span class="fc" id="L1915">	public static String getPageFormatAsString(Paper pPaper) {</span>
		return pPaper.getWidth() + &quot;;&quot; + pPaper.getHeight() + &quot;;&quot;
				+ pPaper.getImageableX() + &quot;;&quot; + pPaper.getImageableY() + &quot;;&quot;
				+ pPaper.getImageableWidth() + &quot;;&quot;
				+ pPaper.getImageableHeight();
	}

	/**
	 * @return
	 */
<span class="nc" id="L1925">	public static String getHostIpAsString() {</span>
		try {
			return InetAddress.getLocalHost().getHostAddress();
		} catch (UnknownHostException e) {
			freemind.main.Resources.getInstance().logException(e);
		}
		return null;
	}

<span class="nc" id="L1934">	public static String printXmlAction(XmlAction pAction) {</span>
		final String classString = pAction.getClass().getName()
				.replaceAll(&quot;.*\\.&quot;, &quot;&quot;);
		if (pAction instanceof CompoundAction) {
			CompoundAction compound = (CompoundAction) pAction;
			StringBuffer buf = new StringBuffer(&quot;[&quot;);
			for (Iterator it = compound.getListChoiceList().iterator(); it
					.hasNext();) {
				if (buf.length() &gt; 1) {
					buf.append(',');
				}
				XmlAction subAction = (XmlAction) it.next();
				buf.append(printXmlAction(subAction));
			}
			buf.append(']');
			return classString + &quot; &quot; + buf.toString();
		}
		return classString;
	}

<span class="nc" id="L1954">	public static XmlAction deepCopy(XmlAction action) {</span>
		return (XmlAction) unMarshall(marshall(action));
	}

<span class="nc" id="L1958">	public static String generateID(String proposedID, HashMap hashMap,</span>
			String prefix) {
		String myProposedID = new String((proposedID != null) ? proposedID : &quot;&quot;);
		String returnValue;
		do {
			if (!myProposedID.isEmpty()) {
				// there is a proposal:
				returnValue = myProposedID;
				// this string is tried only once:
				myProposedID = &quot;&quot;;
			} else {
				/*
				 * The prefix is to enable the id to be an ID in the sense of
				 * XML/DTD.
				 */
				returnValue = prefix
						+ Integer.toString(Tools.ran.nextInt(2000000000));
			}
		} while (hashMap.containsKey(returnValue));
		return returnValue;
	}

	/**
	 * Call this method, if you don't know, if you are in the event thread or
	 * not. It checks this and calls the invokeandwait or the runnable directly.
	 * 
	 * @param pRunnable
	 * @throws InterruptedException
	 * @throws InvocationTargetException
	 */
<span class="nc" id="L1988">	public static void invokeAndWait(Runnable pRunnable)</span>
			throws InvocationTargetException, InterruptedException {
		if (EventQueue.isDispatchThread()) {
			pRunnable.run();
		} else {
			EventQueue.invokeAndWait(pRunnable);
		}
	}

<span class="nc" id="L1997">	public static String getFreeMindBasePath()</span>
			throws UnsupportedEncodingException {
		String path = FreeMindStarter.class.getProtectionDomain()
				.getCodeSource().getLocation().getPath();
		String decodedPath = URLDecoder.decode(path, &quot;UTF-8&quot;);
		logger.info(&quot;Path: &quot; + decodedPath);
		if (decodedPath.endsWith(CONTENTS_JAVA_FREEMIND_JAR)) {
			decodedPath = decodedPath.substring(0, decodedPath.length()
					- CONTENTS_JAVA_FREEMIND_JAR.length());
			decodedPath = decodedPath + FREE_MIND_APP_CONTENTS_RESOURCES_JAVA;
			logger.info(&quot;macPath: &quot; + decodedPath);
		} else if (decodedPath.endsWith(FREEMIND_LIB_FREEMIND_JAR)) {
			decodedPath = decodedPath.substring(0, decodedPath.length()
					- FREEMIND_LIB_FREEMIND_JAR.length());
			logger.info(&quot;reducded Path: &quot; + decodedPath);
		}
		return decodedPath;
	}

<span class="fc" id="L2016">	public static Properties copyChangedProperties(Properties props2,</span>
			Properties defProps2) {
		Properties toBeStored = new Properties();
		for (Iterator it = props2.keySet().iterator(); it.hasNext();) {
			String key = (String) it.next();
			if (!safeEquals(props2.get(key), defProps2.get(key))) {
				toBeStored.put(key, props2.get(key));
			}
		}
		return toBeStored;
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span>freemind (Failed Tests first) (11 May, 2016 1:00:36 PM)</div></body></html>